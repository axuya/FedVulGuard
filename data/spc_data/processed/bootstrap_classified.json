[
  {
    "pair_id": "bootstrap_0000",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public nonReentrant {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.938749194068343,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0001",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public nonReentrant {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.938749194068343,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0002",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public nonReentrant {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.938749194068343,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0003",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.5.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call.value(amount)(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.5.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public nonReentrant {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call.value(amount)(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.9354180829367778,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0004",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      bool res = msg.sender.call.value(amount)();\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.4.2;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      bool res = msg.sender.call.value(amount)();\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.9345047923322684,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0005",
    "source": "smartbugs",
    "original_file": "Rubixi",
    "code_before": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.8.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() public {\n                 creator = payable(msg.sender); //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (payable(msg.sender) == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         fallback() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(payable(msg.sender), (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "code_after": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.8.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n    /// @notice Public function\n         function DynamicPyramid() public {\n                 creator = payable(msg.sender); //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (payable(msg.sender) == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         fallback() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(payable(msg.sender), (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n    /// @notice Public function\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n    /// @notice Public function\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n    /// @notice Public function\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n    /// @notice Public function\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n    /// @notice Public function\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n    /// @notice Public function\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n    /// @notice Public function\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n    /// @notice Public function\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n    /// @notice Public function\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n    /// @notice Public function\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n    /// @notice Public function\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n    /// @notice Public function\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n    /// @notice Public function\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n    /// @notice Public function\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.965,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0006",
    "source": "smartbugs",
    "original_file": "Rubixi",
    "code_before": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.8.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() public {\n                 creator = payable(msg.sender); //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (payable(msg.sender) == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         fallback() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(payable(msg.sender), (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "code_after": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.8.0;\n\n contract Rubixi {\n\n    //Declare variables for storage critical to contract\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address payable private creator;\n\n    //Sets creator\n    // <yes> <report> ACCESS_CONTROL\n    function DynamicPyramid() public {\n    creator = payable(msg.sender); //anyone can call this\n    }\n\n    modifier onlyowner {\n    if (payable(msg.sender) == creator) _;\n    }\n\n    struct Participant {\n    address payable etherAddress;\n    uint payout;\n    }\n\n    Participant[] private participants;\n\n    //Fallback function\n    fallback() external payable {\n    init();\n    }\n\n    //init function run on fallback\n    function init() private {\n    //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n    if (msg.value < 1 ether) {\n    collectedFees += msg.value;\n    return;\n    }\n\n    uint _fee = feePercent;\n    //50% fee rebate on any ether value of 50 or greater\n    if (msg.value >= 50 ether) _fee /= 2;\n\n    addPayout(_fee);\n    }\n\n    //Function called for valid tx to the contract\n    function addPayout(uint _fee) private {\n    //Adds new address to participant array\n    participants.push(Participant(payable(msg.sender), (msg.value * pyramidMultiplier) / 100));\n\n    //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n    if (participants.length == 10) pyramidMultiplier = 200;\n    else if (participants.length == 25) pyramidMultiplier = 150;\n\n    // collect fees and update contract balance\n    balance += (msg.value * (100 - _fee)) / 100;\n    collectedFees += (msg.value * _fee) / 100;\n\n    //Pays earlier participiants if balance sufficient\n    while (balance > participants[payoutOrder].payout) {\n    uint payoutToSend = participants[payoutOrder].payout;\n    participants[payoutOrder].etherAddress.send(payoutToSend);\n\n    balance -= participants[payoutOrder].payout;\n    payoutOrder += 1;\n    }\n    }\n\n    //Fee functions for creator\n    function collectAllFees() public onlyowner {\n    if (collectedFees == 0) revert();\n\n    creator.send(collectedFees);\n    collectedFees = 0;\n    }\n\n    function collectFeesInEther(uint _amt) public onlyowner {\n    _amt *= 1 ether;\n    if (_amt > collectedFees) collectAllFees();\n\n    if (collectedFees == 0) revert();\n\n    creator.send(_amt);\n    collectedFees -= _amt;\n    }\n\n    function collectPercentOfFees(uint _pcent) public onlyowner {\n    if (collectedFees == 0 || _pcent > 100) revert();\n\n    uint feesToCollect = collectedFees / 100 * _pcent;\n    creator.send(feesToCollect);\n    collectedFees -= feesToCollect;\n    }\n\n    //Functions for changing variables related to the contract\n    function changeOwner(address payable _owner) public onlyowner {\n    creator = _owner;\n    }\n\n    function changeMultiplier(uint _mult) public onlyowner {\n    if (_mult > 300 || _mult < 120) revert();\n\n    pyramidMultiplier = _mult;\n    }\n\n    function changeFeePercentage(uint _fee) public onlyowner {\n    if (_fee > 10) revert();\n\n    feePercent = _fee;\n    }\n\n    //Functions to provide information to end-user using JSON interface or other interfaces\n    function currentMultiplier() public view returns(uint multiplier, string memory info) {\n    multiplier = pyramidMultiplier;\n    info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n    }\n\n    function currentFeePercentage() public view returns(uint fee, string memory info) {\n    fee = feePercent;\n    info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n    }\n\n    function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n    pyramidBalance = balance / 1 ether;\n    info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n    }\n\n    function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n    balancePayout = participants[payoutOrder].payout / 1 ether;\n    }\n\n    function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n    fees = collectedFees / 1 ether;\n    }\n\n    function totalParticipants() public view returns(uint count) {\n    count = participants.length;\n    }\n\n    function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n    count = participants.length - payoutOrder;\n    }\n\n    function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n    if (orderInPyramid <= participants.length) {\n    Address = participants[orderInPyramid].etherAddress;\n    Payout = participants[orderInPyramid].payout / 1 ether;\n    }\n    }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.908,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0007",
    "source": "smartbugs",
    "original_file": "EtherLotto",
    "code_before": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 45\n * @author: -\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() {\n        bank = payable(msg.sender);\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            payable(msg.sender).transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "code_after": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 45\n * @author: -\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() {\n    bank = payable(msg.sender);\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n    // Participants must spend some fixed ether before playing lottery.\n    assert(msg.value == TICKET_AMOUNT);\n\n    // Increase pot for each participant.\n    pot += msg.value;\n\n    // Compute some *almost random* value for selecting winner from current transaction.\n    // <yes> <report> TIME_MANIPULATION\n    uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n    // Distribution: 50% of participants will be winners.\n    if (random == 0) {\n\n    // Send fee to bank account.\n    bank.transfer(FEE_AMOUNT);\n\n    // Send jackpot to winner.\n    payable(msg.sender).transfer(pot - FEE_AMOUNT);\n\n    // Restart jackpot.\n    pot = 0;\n    }\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.974,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0008",
    "source": "smartbugs",
    "original_file": "OpenAddressLottery",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            payable(msg.sender).transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(uint160(msg.sender));\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:    1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n    uint component1;\n    uint component2;\n    uint component3;\n    uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n    \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n    owner = msg.sender;\n    reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n    if(msg.value<0.1 ether)\n    return; //verify ticket price\n    \n    // make sure he hasn't won already\n    require(winner[msg.sender] == false);\n    \n    if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n    winner[msg.sender] = true; // every address can only win once\n    \n    uint win=msg.value*7; //win = 7 times the ticket price\n    \n    if(win>address(this).balance) //if the balance isnt sufficient...\n    win=address(this).balance; //...send everything we've got\n    payable(msg.sender).transfer(win);\n    }\n    \n    if(block.number-lastReseed>1000) //reseed if needed\n    reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n    // calculate the number of current address - 1 in 8 chance\n    n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n    secretSeed = uint256(keccak256(abi.encodePacked(\n    components.component1,\n    components.component2,\n    components.component3,\n    components.component4\n    ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n    lastReseed = block.number;\n    }\n    \n    function kill() public {\n    require(msg.sender==owner);\n    \n    selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n    require(msg.sender==owner);\n    // <yes> <report> OTHER - uninitialized storage\n    SeedComponents memory s;\n    s.component1 = uint(uint160(msg.sender));\n    s.component2 = uint256(blockhash(block.number - 1));\n    s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n    s.component4 = tx.gasprice * 7;\n    \n    reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n    if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n    participate();\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.969,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0009",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.ethValue;\n  }\n\n  function withdraw(uint transferAmount) public {\n    if (credit[msg.sender]>= transferAmount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{ethValue: transferAmount}(\"\");\n      credit[msg.sender]-=transferAmount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.967,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0010",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n    /// @notice Public function\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n    /// @notice Public function\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n    /// @notice Public function\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.938,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0011",
    "source": "smartbugs",
    "original_file": "Government",
    "code_before": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = payable(msg.sender);\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             payable(msg.sender).send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(payable(msg.sender));\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 payable(msg.sender).send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     fallback() external payable {\n         lendGovernmentMoney(payable(address(0x0)));\n     }\n\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = payable(msg.sender);\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n    /// @notice Public function\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             payable(msg.sender).send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(payable(msg.sender));\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 payable(msg.sender).send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     fallback() external payable {\n         lendGovernmentMoney(payable(address(0x0)));\n     }\n\n    /// @notice Public function\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n    /// @notice Public function\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    /// @notice Public function\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n    /// @notice Public function\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n    /// @notice Public function\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n    /// @notice Public function\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.979,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0012",
    "source": "smartbugs",
    "original_file": "Government",
    "code_before": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = payable(msg.sender);\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             payable(msg.sender).send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(payable(msg.sender));\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 payable(msg.sender).send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     fallback() external payable {\n         lendGovernmentMoney(payable(address(0x0)));\n     }\n\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract Government {\n\n    // Global Variables\n    uint32 public lastCreditorPayedOut;\n    uint public lastTimeOfNewCredit;\n    uint public profitFromCrash;\n    address payable[] public creditorAddresses;\n    uint[] public creditorAmounts;\n    address payable public corruptElite;\n    mapping (address => uint) buddies;\n    uint constant TWELVE_HOURS = 43200;\n    uint8 public round;\n\n    constructor() payable {\n    // The corrupt elite establishes a new government\n    // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n    profitFromCrash = msg.value;\n    corruptElite = payable(msg.sender);\n    lastTimeOfNewCredit = block.timestamp;\n    }\n\n    function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n    uint amount = msg.value;\n    // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n    // 12h are on average = 60*60*12/12.5 = 3456\n    if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n    // Return money to sender\n    payable(msg.sender).send(amount);\n    // Sends all contract money to the last creditor\n    creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n    corruptElite.send(address(this).balance);\n    // Reset contract state\n    lastCreditorPayedOut = 0;\n    lastTimeOfNewCredit = block.timestamp;\n    profitFromCrash = 0;\n    // <yes> <report> DENIAL_OF_SERVICE\n    creditorAddresses = new address payable[](0);\n    // <yes> <report> DENIAL_OF_SERVICE\n    creditorAmounts = new uint[](0);\n    round += 1;\n    return false;\n    }\n    else {\n    // the system needs to collect at least 1% of the profit from a crash to stay alive\n    if (amount >= 10 ** 18) {\n    // the System has received fresh money, it will survive at leat 12h more\n    lastTimeOfNewCredit = block.timestamp;\n    // register the new creditor and his amount with 10% interest rate\n    creditorAddresses.push(payable(msg.sender));\n    creditorAmounts.push(amount * 110 / 100);\n    // now the money is distributed\n    // first the corrupt elite grabs 5% - thieves!\n    corruptElite.send(amount * 5/100);\n    // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n    if (profitFromCrash < 10000 * 10**18) {\n    profitFromCrash += amount * 5/100;\n    }\n    // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n    // Make a deal with him.\n    if(buddies[buddy] >= amount) {\n    buddy.send(amount * 5/100);\n    }\n    buddies[msg.sender] += amount * 110 / 100;\n    // 90% of the money will be used to pay out old creditors\n    if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n    creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n    buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n    lastCreditorPayedOut += 1;\n    }\n    return true;\n    }\n    else {\n    payable(msg.sender).send(amount);\n    return false;\n    }\n    }\n    }\n\n    // fallback function\n    fallback() external payable {\n    lendGovernmentMoney(payable(address(0x0)));\n    }\n\n    function totalDebt() public view returns (uint debt) {\n    for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n    debt += creditorAmounts[i];\n    }\n    }\n\n    function totalPayedOut() public view returns (uint payout) {\n    for(uint i=0; i<lastCreditorPayedOut; i++){\n    payout += creditorAmounts[i];\n    }\n    }\n\n    // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    function investInTheSystem() public payable {\n    profitFromCrash += msg.value;\n    }\n\n    // From time to time the corrupt elite inherits it's power to the next generation\n    function inheritToNextGeneration(address payable nextGeneration) public {\n    if (msg.sender == corruptElite) {\n    corruptElite = nextGeneration;\n    }\n    }\n\n    function getCreditorAddresses() public view returns (address payable[] memory) {\n    return creditorAddresses;\n    }\n\n    function getCreditorAmounts() public view returns (uint[] memory) {\n    return creditorAmounts;\n    }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.918,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0013",
    "source": "smartbugs",
    "original_file": "Rubixi",
    "code_before": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.6.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() public {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         fallback() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "code_after": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.6.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n    /// @notice Public function\n         function DynamicPyramid() public {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         fallback() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n    /// @notice Public function\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n    /// @notice Public function\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n    /// @notice Public function\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n    /// @notice Public function\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n    /// @notice Public function\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n    /// @notice Public function\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n    /// @notice Public function\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n    /// @notice Public function\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n    /// @notice Public function\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n    /// @notice Public function\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n    /// @notice Public function\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n    /// @notice Public function\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n    /// @notice Public function\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n    /// @notice Public function\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.965,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0014",
    "source": "smartbugs",
    "original_file": "Rubixi",
    "code_before": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.6.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() public {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         fallback() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "code_after": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.6.0;\n\n contract Rubixi {\n\n    //Declare variables for storage critical to contract\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address payable private creator;\n\n    //Sets creator\n    // <yes> <report> ACCESS_CONTROL\n    function DynamicPyramid() public {\n    creator = msg.sender; //anyone can call this\n    }\n\n    modifier onlyowner {\n    if (msg.sender == creator) _;\n    }\n\n    struct Participant {\n    address payable etherAddress;\n    uint payout;\n    }\n\n    Participant[] private participants;\n\n    //Fallback function\n    fallback() external payable {\n    init();\n    }\n\n    //init function run on fallback\n    function init() private {\n    //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n    if (msg.value < 1 ether) {\n    collectedFees += msg.value;\n    return;\n    }\n\n    uint _fee = feePercent;\n    //50% fee rebate on any ether value of 50 or greater\n    if (msg.value >= 50 ether) _fee /= 2;\n\n    addPayout(_fee);\n    }\n\n    //Function called for valid tx to the contract\n    function addPayout(uint _fee) private {\n    //Adds new address to participant array\n    participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n    //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n    if (participants.length == 10) pyramidMultiplier = 200;\n    else if (participants.length == 25) pyramidMultiplier = 150;\n\n    // collect fees and update contract balance\n    balance += (msg.value * (100 - _fee)) / 100;\n    collectedFees += (msg.value * _fee) / 100;\n\n    //Pays earlier participiants if balance sufficient\n    while (balance > participants[payoutOrder].payout) {\n    uint payoutToSend = participants[payoutOrder].payout;\n    participants[payoutOrder].etherAddress.send(payoutToSend);\n\n    balance -= participants[payoutOrder].payout;\n    payoutOrder += 1;\n    }\n    }\n\n    //Fee functions for creator\n    function collectAllFees() public onlyowner {\n    if (collectedFees == 0) revert();\n\n    creator.send(collectedFees);\n    collectedFees = 0;\n    }\n\n    function collectFeesInEther(uint _amt) public onlyowner {\n    _amt *= 1 ether;\n    if (_amt > collectedFees) collectAllFees();\n\n    if (collectedFees == 0) revert();\n\n    creator.send(_amt);\n    collectedFees -= _amt;\n    }\n\n    function collectPercentOfFees(uint _pcent) public onlyowner {\n    if (collectedFees == 0 || _pcent > 100) revert();\n\n    uint feesToCollect = collectedFees / 100 * _pcent;\n    creator.send(feesToCollect);\n    collectedFees -= feesToCollect;\n    }\n\n    //Functions for changing variables related to the contract\n    function changeOwner(address payable _owner) public onlyowner {\n    creator = _owner;\n    }\n\n    function changeMultiplier(uint _mult) public onlyowner {\n    if (_mult > 300 || _mult < 120) revert();\n\n    pyramidMultiplier = _mult;\n    }\n\n    function changeFeePercentage(uint _fee) public onlyowner {\n    if (_fee > 10) revert();\n\n    feePercent = _fee;\n    }\n\n    //Functions to provide information to end-user using JSON interface or other interfaces\n    function currentMultiplier() public view returns(uint multiplier, string memory info) {\n    multiplier = pyramidMultiplier;\n    info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n    }\n\n    function currentFeePercentage() public view returns(uint fee, string memory info) {\n    fee = feePercent;\n    info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n    }\n\n    function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n    pyramidBalance = balance / 1 ether;\n    info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n    }\n\n    function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n    balancePayout = participants[payoutOrder].payout / 1 ether;\n    }\n\n    function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n    fees = collectedFees / 1 ether;\n    }\n\n    function totalParticipants() public view returns(uint count) {\n    count = participants.length;\n    }\n\n    function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n    count = participants.length - payoutOrder;\n    }\n\n    function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n    if (orderInPyramid <= participants.length) {\n    Address = participants[orderInPyramid].etherAddress;\n    Payout = participants[orderInPyramid].payout / 1 ether;\n    }\n    }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.907,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0015",
    "source": "smartbugs",
    "original_file": "EtherLotto",
    "code_before": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @vulnerable_at_lines: 45\n * @author: -\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() public {\n        bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "code_after": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @vulnerable_at_lines: 45\n * @author: -\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() public {\n    bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n    // Participants must spend some fixed ether before playing lottery.\n    assert(msg.value == TICKET_AMOUNT);\n\n    // Increase pot for each participant.\n    pot += msg.value;\n\n    // Compute some *almost random* value for selecting winner from current transaction.\n    // <yes> <report> TIME_MANIPULATION\n    uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n    // Distribution: 50% of participants will be winners.\n    if (random == 0) {\n\n    // Send fee to bank account.\n    bank.transfer(FEE_AMOUNT);\n\n    // Send jackpot to winner.\n    msg.sender.transfer(pot - FEE_AMOUNT);\n\n    // Restart jackpot.\n    pot = 0;\n    }\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.974,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0016",
    "source": "smartbugs",
    "original_file": "OpenAddressLottery",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The contractOwner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any transferAmount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole userBalance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address contractOwner; //address of the contractOwner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        contractOwner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.ethValue<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.ethValue*7; //win = 7 times the ticket price\n            \n            if(win>address(this).userBalance) //if the userBalance isnt sufficient...\n                win=address(this).userBalance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==contractOwner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the contractOwner - for testing purposes\n        require(msg.sender==contractOwner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.ethValue>=0.1 ether && msg.sender!=contractOwner) //contractOwner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.98,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0017",
    "source": "smartbugs",
    "original_file": "OpenAddressLottery",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:    1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n    uint component1;\n    uint component2;\n    uint component3;\n    uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n    \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n    owner = msg.sender;\n    reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n    if(msg.value<0.1 ether)\n    return; //verify ticket price\n    \n    // make sure he hasn't won already\n    require(winner[msg.sender] == false);\n    \n    if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n    winner[msg.sender] = true; // every address can only win once\n    \n    uint win=msg.value*7; //win = 7 times the ticket price\n    \n    if(win>address(this).balance) //if the balance isnt sufficient...\n    win=address(this).balance; //...send everything we've got\n    msg.sender.transfer(win);\n    }\n    \n    if(block.number-lastReseed>1000) //reseed if needed\n    reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n    // calculate the number of current address - 1 in 8 chance\n    n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n    secretSeed = uint256(keccak256(abi.encodePacked(\n    components.component1,\n    components.component2,\n    components.component3,\n    components.component4\n    ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n    lastReseed = block.number;\n    }\n    \n    function kill() public {\n    require(msg.sender==owner);\n    \n    selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n    require(msg.sender==owner);\n    // <yes> <report> OTHER - uninitialized storage\n    SeedComponents memory s;\n    s.component1 = uint(msg.sender);\n    s.component2 = uint256(blockhash(block.number - 1));\n    s.component3 = block.difficulty*(uint)(block.coinbase);\n    s.component4 = tx.gasprice * 7;\n    \n    reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n    if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n    participate();\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.968,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0018",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.ethValue;\n  }\n\n  function withdraw(uint transferAmount) public {\n    if (credit[msg.sender]>= transferAmount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{ethValue: transferAmount}(\"\");\n      credit[msg.sender]-=transferAmount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.967,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0019",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n    /// @notice Public function\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n    /// @notice Public function\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n    /// @notice Public function\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.938,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0020",
    "source": "smartbugs",
    "original_file": "Government",
    "code_before": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() public payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     fallback() external payable {\n         lendGovernmentMoney(address(0x0));\n     }\n\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() public payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n    /// @notice Public function\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     fallback() external payable {\n         lendGovernmentMoney(address(0x0));\n     }\n\n    /// @notice Public function\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n    /// @notice Public function\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    /// @notice Public function\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n    /// @notice Public function\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n    /// @notice Public function\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n    /// @notice Public function\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.979,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0021",
    "source": "smartbugs",
    "original_file": "Government",
    "code_before": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() public payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     fallback() external payable {\n         lendGovernmentMoney(address(0x0));\n     }\n\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract Government {\n\n    // Global Variables\n    uint32 public lastCreditorPayedOut;\n    uint public lastTimeOfNewCredit;\n    uint public profitFromCrash;\n    address payable[] public creditorAddresses;\n    uint[] public creditorAmounts;\n    address payable public corruptElite;\n    mapping (address => uint) buddies;\n    uint constant TWELVE_HOURS = 43200;\n    uint8 public round;\n\n    constructor() public payable {\n    // The corrupt elite establishes a new government\n    // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n    profitFromCrash = msg.value;\n    corruptElite = msg.sender;\n    lastTimeOfNewCredit = block.timestamp;\n    }\n\n    function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n    uint amount = msg.value;\n    // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n    // 12h are on average = 60*60*12/12.5 = 3456\n    if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n    // Return money to sender\n    msg.sender.send(amount);\n    // Sends all contract money to the last creditor\n    creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n    corruptElite.send(address(this).balance);\n    // Reset contract state\n    lastCreditorPayedOut = 0;\n    lastTimeOfNewCredit = block.timestamp;\n    profitFromCrash = 0;\n    // <yes> <report> DENIAL_OF_SERVICE\n    creditorAddresses = new address payable[](0);\n    // <yes> <report> DENIAL_OF_SERVICE\n    creditorAmounts = new uint[](0);\n    round += 1;\n    return false;\n    }\n    else {\n    // the system needs to collect at least 1% of the profit from a crash to stay alive\n    if (amount >= 10 ** 18) {\n    // the System has received fresh money, it will survive at leat 12h more\n    lastTimeOfNewCredit = block.timestamp;\n    // register the new creditor and his amount with 10% interest rate\n    creditorAddresses.push(msg.sender);\n    creditorAmounts.push(amount * 110 / 100);\n    // now the money is distributed\n    // first the corrupt elite grabs 5% - thieves!\n    corruptElite.send(amount * 5/100);\n    // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n    if (profitFromCrash < 10000 * 10**18) {\n    profitFromCrash += amount * 5/100;\n    }\n    // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n    // Make a deal with him.\n    if(buddies[buddy] >= amount) {\n    buddy.send(amount * 5/100);\n    }\n    buddies[msg.sender] += amount * 110 / 100;\n    // 90% of the money will be used to pay out old creditors\n    if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n    creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n    buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n    lastCreditorPayedOut += 1;\n    }\n    return true;\n    }\n    else {\n    msg.sender.send(amount);\n    return false;\n    }\n    }\n    }\n\n    // fallback function\n    fallback() external payable {\n    lendGovernmentMoney(address(0x0));\n    }\n\n    function totalDebt() public view returns (uint debt) {\n    for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n    debt += creditorAmounts[i];\n    }\n    }\n\n    function totalPayedOut() public view returns (uint payout) {\n    for(uint i=0; i<lastCreditorPayedOut; i++){\n    payout += creditorAmounts[i];\n    }\n    }\n\n    // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    function investInTheSystem() public payable {\n    profitFromCrash += msg.value;\n    }\n\n    // From time to time the corrupt elite inherits it's power to the next generation\n    function inheritToNextGeneration(address payable nextGeneration) public {\n    if (msg.sender == corruptElite) {\n    corruptElite = nextGeneration;\n    }\n    }\n\n    function getCreditorAddresses() public view returns (address payable[] memory) {\n    return creditorAddresses;\n    }\n\n    function getCreditorAmounts() public view returns (uint[] memory) {\n    return creditorAmounts;\n    }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.917,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0022",
    "source": "smartbugs",
    "original_file": "Rubixi",
    "code_before": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.7.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() public {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         fallback() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "code_after": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.7.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n    /// @notice Public function\n         function DynamicPyramid() public {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         fallback() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n    /// @notice Public function\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n    /// @notice Public function\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n    /// @notice Public function\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n    /// @notice Public function\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n    /// @notice Public function\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n    /// @notice Public function\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n    /// @notice Public function\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n    /// @notice Public function\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n    /// @notice Public function\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n    /// @notice Public function\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n    /// @notice Public function\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n    /// @notice Public function\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n    /// @notice Public function\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n    /// @notice Public function\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.965,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0023",
    "source": "smartbugs",
    "original_file": "Rubixi",
    "code_before": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.7.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() public {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         fallback() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "code_after": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 25,26\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.7.0;\n\n contract Rubixi {\n\n    //Declare variables for storage critical to contract\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address payable private creator;\n\n    //Sets creator\n    // <yes> <report> ACCESS_CONTROL\n    function DynamicPyramid() public {\n    creator = msg.sender; //anyone can call this\n    }\n\n    modifier onlyowner {\n    if (msg.sender == creator) _;\n    }\n\n    struct Participant {\n    address payable etherAddress;\n    uint payout;\n    }\n\n    Participant[] private participants;\n\n    //Fallback function\n    fallback() external payable {\n    init();\n    }\n\n    //init function run on fallback\n    function init() private {\n    //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n    if (msg.value < 1 ether) {\n    collectedFees += msg.value;\n    return;\n    }\n\n    uint _fee = feePercent;\n    //50% fee rebate on any ether value of 50 or greater\n    if (msg.value >= 50 ether) _fee /= 2;\n\n    addPayout(_fee);\n    }\n\n    //Function called for valid tx to the contract\n    function addPayout(uint _fee) private {\n    //Adds new address to participant array\n    participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n    //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n    if (participants.length == 10) pyramidMultiplier = 200;\n    else if (participants.length == 25) pyramidMultiplier = 150;\n\n    // collect fees and update contract balance\n    balance += (msg.value * (100 - _fee)) / 100;\n    collectedFees += (msg.value * _fee) / 100;\n\n    //Pays earlier participiants if balance sufficient\n    while (balance > participants[payoutOrder].payout) {\n    uint payoutToSend = participants[payoutOrder].payout;\n    participants[payoutOrder].etherAddress.send(payoutToSend);\n\n    balance -= participants[payoutOrder].payout;\n    payoutOrder += 1;\n    }\n    }\n\n    //Fee functions for creator\n    function collectAllFees() public onlyowner {\n    if (collectedFees == 0) revert();\n\n    creator.send(collectedFees);\n    collectedFees = 0;\n    }\n\n    function collectFeesInEther(uint _amt) public onlyowner {\n    _amt *= 1 ether;\n    if (_amt > collectedFees) collectAllFees();\n\n    if (collectedFees == 0) revert();\n\n    creator.send(_amt);\n    collectedFees -= _amt;\n    }\n\n    function collectPercentOfFees(uint _pcent) public onlyowner {\n    if (collectedFees == 0 || _pcent > 100) revert();\n\n    uint feesToCollect = collectedFees / 100 * _pcent;\n    creator.send(feesToCollect);\n    collectedFees -= feesToCollect;\n    }\n\n    //Functions for changing variables related to the contract\n    function changeOwner(address payable _owner) public onlyowner {\n    creator = _owner;\n    }\n\n    function changeMultiplier(uint _mult) public onlyowner {\n    if (_mult > 300 || _mult < 120) revert();\n\n    pyramidMultiplier = _mult;\n    }\n\n    function changeFeePercentage(uint _fee) public onlyowner {\n    if (_fee > 10) revert();\n\n    feePercent = _fee;\n    }\n\n    //Functions to provide information to end-user using JSON interface or other interfaces\n    function currentMultiplier() public view returns(uint multiplier, string memory info) {\n    multiplier = pyramidMultiplier;\n    info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n    }\n\n    function currentFeePercentage() public view returns(uint fee, string memory info) {\n    fee = feePercent;\n    info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n    }\n\n    function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n    pyramidBalance = balance / 1 ether;\n    info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n    }\n\n    function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n    balancePayout = participants[payoutOrder].payout / 1 ether;\n    }\n\n    function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n    fees = collectedFees / 1 ether;\n    }\n\n    function totalParticipants() public view returns(uint count) {\n    count = participants.length;\n    }\n\n    function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n    count = participants.length - payoutOrder;\n    }\n\n    function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n    if (orderInPyramid <= participants.length) {\n    Address = participants[orderInPyramid].etherAddress;\n    Payout = participants[orderInPyramid].payout / 1 ether;\n    }\n    }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.907,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0024",
    "source": "smartbugs",
    "original_file": "EtherLotto",
    "code_before": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @vulnerable_at_lines: 45\n * @author: -\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() {\n        bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "code_after": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @vulnerable_at_lines: 45\n * @author: -\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() {\n    bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n    // Participants must spend some fixed ether before playing lottery.\n    assert(msg.value == TICKET_AMOUNT);\n\n    // Increase pot for each participant.\n    pot += msg.value;\n\n    // Compute some *almost random* value for selecting winner from current transaction.\n    // <yes> <report> TIME_MANIPULATION\n    uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n    // Distribution: 50% of participants will be winners.\n    if (random == 0) {\n\n    // Send fee to bank account.\n    bank.transfer(FEE_AMOUNT);\n\n    // Send jackpot to winner.\n    msg.sender.transfer(pot - FEE_AMOUNT);\n\n    // Restart jackpot.\n    pot = 0;\n    }\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.974,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0025",
    "source": "solidifi",
    "original_file": "overflow",
    "code_before": "pragma solidity ^0.5.0;\n\n\ncontract Over {\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n\n  function sendeth(address _to, uint _value) public returns (bool) {\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n",
    "code_after": "pragma solidity ^0.5.0;\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n\ncontract Over {\n    using SafeMath for uint256;\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n\n  function sendeth(address _to, uint _value) public returns (bool) {\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n",
    "vulnerability_type": "overflow",
    "similarity": 0.9214659685863874,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0026",
    "source": "smartbugs",
    "original_file": "ReturnValue",
    "code_before": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "code_after": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract ReturnValue {\n\n    /// @notice Public function\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n    /// @notice Public function\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "vulnerability_type": "overflow",
    "similarity": 0.945,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0027",
    "source": "smartbugs",
    "original_file": "ReturnValue",
    "code_before": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "code_after": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract ReturnValue {\n\n    /// @notice Public function\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n    /// @notice Public function\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "vulnerability_type": "overflow",
    "similarity": 0.945,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0028",
    "source": "smartbugs",
    "original_file": "ReturnValue",
    "code_before": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "code_after": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract ReturnValue {\n\n    /// @notice Public function\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n    /// @notice Public function\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "vulnerability_type": "overflow",
    "similarity": 0.945,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0029",
    "source": "smartbugs",
    "original_file": "ReturnValue",
    "code_before": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.5.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "code_after": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.5.0;\n\ncontract ReturnValue {\n\n    /// @notice Public function\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n    /// @notice Public function\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "vulnerability_type": "overflow",
    "similarity": 0.941,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0030",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint transferAmount) public returns(bool sufficient) {\n         if (balances[msg.sender] < transferAmount) return false;\n         balances[msg.sender] -= transferAmount;\n         balances[to] += transferAmount;\n         emit Transfer(msg.sender, to, transferAmount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.973,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0031",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n    /// @notice Public function\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n    /// @notice Public function\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.966,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0032",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n contract MyToken {\n    mapping (address => uint) balances;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    constructor() {\n    balances[tx.origin] = 10000;\n    }\n    // <yes> <report> SHORT_ADDRESSES\n    function sendCoin(address to, uint amount) public returns(bool sufficient) {\n    if (balances[msg.sender] < amount) return false;\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    emit Transfer(msg.sender, to, amount);\n    return true;\n    }\n\n    function getBalance(address addr) public view returns(uint) {\n    return balances[addr];\n    }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.961,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0033",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint transferAmount) public returns(bool sufficient) {\n         if (balances[msg.sender] < transferAmount) return false;\n         balances[msg.sender] -= transferAmount;\n         balances[to] += transferAmount;\n         emit Transfer(msg.sender, to, transferAmount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.973,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0034",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n    /// @notice Public function\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n    /// @notice Public function\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.966,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0035",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n contract MyToken {\n    mapping (address => uint) balances;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    constructor() public {\n    balances[tx.origin] = 10000;\n    }\n    // <yes> <report> SHORT_ADDRESSES\n    function sendCoin(address to, uint amount) public returns(bool sufficient) {\n    if (balances[msg.sender] < amount) return false;\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    emit Transfer(msg.sender, to, amount);\n    return true;\n    }\n\n    function getBalance(address addr) public view returns(uint) {\n    return balances[addr];\n    }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.961,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0036",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint transferAmount) public returns(bool sufficient) {\n         if (balances[msg.sender] < transferAmount) return false;\n         balances[msg.sender] -= transferAmount;\n         balances[to] += transferAmount;\n         emit Transfer(msg.sender, to, transferAmount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.973,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0037",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n    /// @notice Public function\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n    /// @notice Public function\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.966,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0038",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n contract MyToken {\n    mapping (address => uint) balances;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    constructor() {\n    balances[tx.origin] = 10000;\n    }\n    // <yes> <report> SHORT_ADDRESSES\n    function sendCoin(address to, uint amount) public returns(bool sufficient) {\n    if (balances[msg.sender] < amount) return false;\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    emit Transfer(msg.sender, to, amount);\n    return true;\n    }\n\n    function getBalance(address addr) public view returns(uint) {\n    return balances[addr];\n    }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.961,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0039",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\n pragma solidity ^0.5.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\n pragma solidity ^0.5.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint transferAmount) public returns(bool sufficient) {\n         if (balances[msg.sender] < transferAmount) return false;\n         balances[msg.sender] -= transferAmount;\n         balances[to] += transferAmount;\n         emit Transfer(msg.sender, to, transferAmount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.972,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0040",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\n pragma solidity ^0.5.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\n pragma solidity ^0.5.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n    /// @notice Public function\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n    /// @notice Public function\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.965,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0041",
    "source": "smartbugs",
    "original_file": "MyToken",
    "code_before": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\n pragma solidity ^0.5.0;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     constructor() public {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) public returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         emit Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) public view returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "code_after": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\n pragma solidity ^0.5.0;\n\n contract MyToken {\n    mapping (address => uint) balances;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    constructor() public {\n    balances[tx.origin] = 10000;\n    }\n    // <yes> <report> SHORT_ADDRESSES\n    function sendCoin(address to, uint amount) public returns(bool sufficient) {\n    if (balances[msg.sender] < amount) return false;\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    emit Transfer(msg.sender, to, amount);\n    return true;\n    }\n\n    function getBalance(address addr) public view returns(uint) {\n    return balances[addr];\n    }\n }\n",
    "vulnerability_type": "access_control",
    "similarity": 0.959,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0042",
    "code_before": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * @vulnerable_at_lines: 43\n * @author: -\n */\n\n pragma solidity ^0.4.15;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    function EtherLotto() {\n        bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        var random = uint(sha3(block.timestamp)) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "code_after": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 45\n * @author: -\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() {\n        bank = payable(msg.sender);\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            payable(msg.sender).transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "vulnerability_type": "unknown",
    "similarity": 0.9285309132161089,
    "before_source": "EtherLotto",
    "after_source": "EtherLotto",
    "method": "similarity_matching",
    "needs_manual_review": true,
    "quality_score": 0.5
  },
  {
    "pair_id": "bootstrap_0043",
    "code_before": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.5.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "code_after": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "vulnerability_type": "unknown",
    "similarity": 0.9555345316934721,
    "before_source": "ReturnValue",
    "after_source": "ReturnValue",
    "method": "similarity_matching",
    "needs_manual_review": true,
    "quality_score": 0.5
  },
  {
    "pair_id": "bootstrap_0044",
    "code_before": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    require(callee.call());\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call();\n  }\n}\n",
    "code_after": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "vulnerability_type": "unchecked_call",
    "similarity": 0.7936842105263158,
    "before_source": "ReturnValue",
    "after_source": "ReturnValue",
    "method": "similarity_matching",
    "needs_manual_review": true,
    "quality_score": 0.5,
    "_classification_reason": [
      "checks call return value",
      "requires call success"
    ],
    "_classification_confidence": 2
  },
  {
    "pair_id": "bootstrap_0045",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            payable(msg.sender).transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(uint160(msg.sender));\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "access_control",
    "similarity": 0.9666628215480447,
    "before_source": "OpenAddressLottery",
    "after_source": "OpenAddressLottery",
    "method": "similarity_matching",
    "needs_manual_review": true,
    "quality_score": 0.5,
    "_classification_reason": [
      "checks owner",
      "has selfdestruct"
    ],
    "_classification_confidence": 2
  },
  {
    "pair_id": "bootstrap_0046",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            payable(msg.sender).transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(uint160(msg.sender));\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "access_control",
    "similarity": 0.967444008312168,
    "before_source": "OpenAddressLottery",
    "after_source": "OpenAddressLottery",
    "method": "similarity_matching",
    "needs_manual_review": true,
    "quality_score": 0.5,
    "_classification_reason": [
      "checks owner",
      "has selfdestruct"
    ],
    "_classification_confidence": 2
  },
  {
    "pair_id": "bootstrap_0047",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @vulnerable_at_lines: 92\n */\n\npragma solidity ^0.5.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            payable(msg.sender).transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(uint160(msg.sender));\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "access_control",
    "similarity": 0.9704553354188391,
    "before_source": "OpenAddressLottery",
    "after_source": "OpenAddressLottery",
    "method": "similarity_matching",
    "needs_manual_review": true,
    "quality_score": 0.5,
    "_classification_reason": [
      "checks owner",
      "has selfdestruct"
    ],
    "_classification_confidence": 2
  },
  {
    "pair_id": "bootstrap_0048",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * @vulnerable_at_lines: 91\n */\n\npragma solidity ^0.4.19;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    function OpenAddressLottery() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>this.balance) //if the balance isnt sufficient...\n                win=this.balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;\n    }\n    \n    function reseed(SeedComponents components) internal {\n        secretSeed = uint256(keccak256(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(block.blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            payable(msg.sender).transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(uint160(msg.sender));\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "access_control",
    "similarity": 0.927710843373494,
    "before_source": "OpenAddressLottery",
    "after_source": "OpenAddressLottery",
    "method": "similarity_matching",
    "needs_manual_review": true,
    "quality_score": 0.5,
    "_classification_reason": [
      "checks owner",
      "has selfdestruct"
    ],
    "_classification_confidence": 2
  },
  {
    "pair_id": "bootstrap_0049",
    "source": "smartbugs",
    "original_file": "OpenAddressLottery",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The contractOwner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any transferAmount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole userBalance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address contractOwner; //address of the contractOwner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        contractOwner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.ethValue<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.ethValue*7; //win = 7 times the ticket price\n            \n            if(win>address(this).userBalance) //if the userBalance isnt sufficient...\n                win=address(this).userBalance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==contractOwner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the contractOwner - for testing purposes\n        require(msg.sender==contractOwner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.ethValue>=0.1 ether && msg.sender!=contractOwner) //contractOwner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.98,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0050",
    "source": "smartbugs",
    "original_file": "OpenAddressLottery",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:    1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n    uint component1;\n    uint component2;\n    uint component3;\n    uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n    \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n    owner = msg.sender;\n    reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n    if(msg.value<0.1 ether)\n    return; //verify ticket price\n    \n    // make sure he hasn't won already\n    require(winner[msg.sender] == false);\n    \n    if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n    winner[msg.sender] = true; // every address can only win once\n    \n    uint win=msg.value*7; //win = 7 times the ticket price\n    \n    if(win>address(this).balance) //if the balance isnt sufficient...\n    win=address(this).balance; //...send everything we've got\n    msg.sender.transfer(win);\n    }\n    \n    if(block.number-lastReseed>1000) //reseed if needed\n    reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n    // calculate the number of current address - 1 in 8 chance\n    n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n    secretSeed = uint256(keccak256(abi.encodePacked(\n    components.component1,\n    components.component2,\n    components.component3,\n    components.component4\n    ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n    lastReseed = block.number;\n    }\n    \n    function kill() public {\n    require(msg.sender==owner);\n    \n    selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n    require(msg.sender==owner);\n    // <yes> <report> OTHER - uninitialized storage\n    SeedComponents memory s;\n    s.component1 = uint(msg.sender);\n    s.component2 = uint256(blockhash(block.number - 1));\n    s.component3 = block.difficulty*(uint)(block.coinbase);\n    s.component4 = tx.gasprice * 7;\n    \n    reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n    if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n    participate();\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.968,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0051",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.ethValue;\n  }\n\n  function withdraw(uint transferAmount) public {\n    if (credit[msg.sender]>= transferAmount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{ethValue: transferAmount}(\"\");\n      credit[msg.sender]-=transferAmount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.967,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0052",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n    /// @notice Public function\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n    /// @notice Public function\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n    /// @notice Public function\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.938,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0053",
    "source": "smartbugs",
    "original_file": "Government",
    "code_before": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     fallback() external payable {\n         lendGovernmentMoney(address(0x0));\n     }\n\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n    /// @notice Public function\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     fallback() external payable {\n         lendGovernmentMoney(address(0x0));\n     }\n\n    /// @notice Public function\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n    /// @notice Public function\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    /// @notice Public function\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n    /// @notice Public function\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n    /// @notice Public function\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n    /// @notice Public function\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.979,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0054",
    "source": "smartbugs",
    "original_file": "Government",
    "code_before": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     fallback() external payable {\n         lendGovernmentMoney(address(0x0));\n     }\n\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract Government {\n\n    // Global Variables\n    uint32 public lastCreditorPayedOut;\n    uint public lastTimeOfNewCredit;\n    uint public profitFromCrash;\n    address payable[] public creditorAddresses;\n    uint[] public creditorAmounts;\n    address payable public corruptElite;\n    mapping (address => uint) buddies;\n    uint constant TWELVE_HOURS = 43200;\n    uint8 public round;\n\n    constructor() payable {\n    // The corrupt elite establishes a new government\n    // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n    profitFromCrash = msg.value;\n    corruptElite = msg.sender;\n    lastTimeOfNewCredit = block.timestamp;\n    }\n\n    function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n    uint amount = msg.value;\n    // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n    // 12h are on average = 60*60*12/12.5 = 3456\n    if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n    // Return money to sender\n    msg.sender.send(amount);\n    // Sends all contract money to the last creditor\n    creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n    corruptElite.send(address(this).balance);\n    // Reset contract state\n    lastCreditorPayedOut = 0;\n    lastTimeOfNewCredit = block.timestamp;\n    profitFromCrash = 0;\n    // <yes> <report> DENIAL_OF_SERVICE\n    creditorAddresses = new address payable[](0);\n    // <yes> <report> DENIAL_OF_SERVICE\n    creditorAmounts = new uint[](0);\n    round += 1;\n    return false;\n    }\n    else {\n    // the system needs to collect at least 1% of the profit from a crash to stay alive\n    if (amount >= 10 ** 18) {\n    // the System has received fresh money, it will survive at leat 12h more\n    lastTimeOfNewCredit = block.timestamp;\n    // register the new creditor and his amount with 10% interest rate\n    creditorAddresses.push(msg.sender);\n    creditorAmounts.push(amount * 110 / 100);\n    // now the money is distributed\n    // first the corrupt elite grabs 5% - thieves!\n    corruptElite.send(amount * 5/100);\n    // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n    if (profitFromCrash < 10000 * 10**18) {\n    profitFromCrash += amount * 5/100;\n    }\n    // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n    // Make a deal with him.\n    if(buddies[buddy] >= amount) {\n    buddy.send(amount * 5/100);\n    }\n    buddies[msg.sender] += amount * 110 / 100;\n    // 90% of the money will be used to pay out old creditors\n    if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n    creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n    buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n    lastCreditorPayedOut += 1;\n    }\n    return true;\n    }\n    else {\n    msg.sender.send(amount);\n    return false;\n    }\n    }\n    }\n\n    // fallback function\n    fallback() external payable {\n    lendGovernmentMoney(address(0x0));\n    }\n\n    function totalDebt() public view returns (uint debt) {\n    for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n    debt += creditorAmounts[i];\n    }\n    }\n\n    function totalPayedOut() public view returns (uint payout) {\n    for(uint i=0; i<lastCreditorPayedOut; i++){\n    payout += creditorAmounts[i];\n    }\n    }\n\n    // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    function investInTheSystem() public payable {\n    profitFromCrash += msg.value;\n    }\n\n    // From time to time the corrupt elite inherits it's power to the next generation\n    function inheritToNextGeneration(address payable nextGeneration) public {\n    if (msg.sender == corruptElite) {\n    corruptElite = nextGeneration;\n    }\n    }\n\n    function getCreditorAddresses() public view returns (address payable[] memory) {\n    return creditorAddresses;\n    }\n\n    function getCreditorAmounts() public view returns (uint[] memory) {\n    return creditorAmounts;\n    }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.917,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0055",
    "source": "smartbugs",
    "original_file": "Rubixi",
    "code_before": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 24,25\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n pragma solidity ^0.5.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() public {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         function() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "code_after": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 24,25\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n pragma solidity ^0.5.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n    /// @notice Public function\n         function DynamicPyramid() public {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         function() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n    /// @notice Public function\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n    /// @notice Public function\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n    /// @notice Public function\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n    /// @notice Public function\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n    /// @notice Public function\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n    /// @notice Public function\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n    /// @notice Public function\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n    /// @notice Public function\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n    /// @notice Public function\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n    /// @notice Public function\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n    /// @notice Public function\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n    /// @notice Public function\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n    /// @notice Public function\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n    /// @notice Public function\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.965,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0056",
    "source": "smartbugs",
    "original_file": "Rubixi",
    "code_before": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 24,25\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n pragma solidity ^0.5.0;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address payable private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() public {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address payable etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         function() external payable {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() public onlyowner {\n                 if (collectedFees == 0) revert();\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) public onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) revert();\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) public onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) revert();\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address payable _owner) public onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) public onlyowner {\n                 if (_mult > 300 || _mult < 120) revert();\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) public onlyowner {\n                 if (_fee > 10) revert();\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() public view returns(uint multiplier, string memory info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() public view returns(uint fee, string memory info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() public view returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "code_after": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 24,25\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n pragma solidity ^0.5.0;\n\n contract Rubixi {\n\n    //Declare variables for storage critical to contract\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address payable private creator;\n\n    //Sets creator\n    // <yes> <report> ACCESS_CONTROL\n    function DynamicPyramid() public {\n    creator = msg.sender; //anyone can call this\n    }\n\n    modifier onlyowner {\n    if (msg.sender == creator) _;\n    }\n\n    struct Participant {\n    address payable etherAddress;\n    uint payout;\n    }\n\n    Participant[] private participants;\n\n    //Fallback function\n    function() external payable {\n    init();\n    }\n\n    //init function run on fallback\n    function init() private {\n    //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n    if (msg.value < 1 ether) {\n    collectedFees += msg.value;\n    return;\n    }\n\n    uint _fee = feePercent;\n    //50% fee rebate on any ether value of 50 or greater\n    if (msg.value >= 50 ether) _fee /= 2;\n\n    addPayout(_fee);\n    }\n\n    //Function called for valid tx to the contract\n    function addPayout(uint _fee) private {\n    //Adds new address to participant array\n    participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n    //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n    if (participants.length == 10) pyramidMultiplier = 200;\n    else if (participants.length == 25) pyramidMultiplier = 150;\n\n    // collect fees and update contract balance\n    balance += (msg.value * (100 - _fee)) / 100;\n    collectedFees += (msg.value * _fee) / 100;\n\n    //Pays earlier participiants if balance sufficient\n    while (balance > participants[payoutOrder].payout) {\n    uint payoutToSend = participants[payoutOrder].payout;\n    participants[payoutOrder].etherAddress.send(payoutToSend);\n\n    balance -= participants[payoutOrder].payout;\n    payoutOrder += 1;\n    }\n    }\n\n    //Fee functions for creator\n    function collectAllFees() public onlyowner {\n    if (collectedFees == 0) revert();\n\n    creator.send(collectedFees);\n    collectedFees = 0;\n    }\n\n    function collectFeesInEther(uint _amt) public onlyowner {\n    _amt *= 1 ether;\n    if (_amt > collectedFees) collectAllFees();\n\n    if (collectedFees == 0) revert();\n\n    creator.send(_amt);\n    collectedFees -= _amt;\n    }\n\n    function collectPercentOfFees(uint _pcent) public onlyowner {\n    if (collectedFees == 0 || _pcent > 100) revert();\n\n    uint feesToCollect = collectedFees / 100 * _pcent;\n    creator.send(feesToCollect);\n    collectedFees -= feesToCollect;\n    }\n\n    //Functions for changing variables related to the contract\n    function changeOwner(address payable _owner) public onlyowner {\n    creator = _owner;\n    }\n\n    function changeMultiplier(uint _mult) public onlyowner {\n    if (_mult > 300 || _mult < 120) revert();\n\n    pyramidMultiplier = _mult;\n    }\n\n    function changeFeePercentage(uint _fee) public onlyowner {\n    if (_fee > 10) revert();\n\n    feePercent = _fee;\n    }\n\n    //Functions to provide information to end-user using JSON interface or other interfaces\n    function currentMultiplier() public view returns(uint multiplier, string memory info) {\n    multiplier = pyramidMultiplier;\n    info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n    }\n\n    function currentFeePercentage() public view returns(uint fee, string memory info) {\n    fee = feePercent;\n    info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n    }\n\n    function currentPyramidBalanceApproximately() public view returns(uint pyramidBalance, string memory info) {\n    pyramidBalance = balance / 1 ether;\n    info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n    }\n\n    function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns(uint balancePayout) {\n    balancePayout = participants[payoutOrder].payout / 1 ether;\n    }\n\n    function feesSeperateFromBalanceApproximately() public view returns(uint fees) {\n    fees = collectedFees / 1 ether;\n    }\n\n    function totalParticipants() public view returns(uint count) {\n    count = participants.length;\n    }\n\n    function numberOfParticipantsWaitingForPayout() public view returns(uint count) {\n    count = participants.length - payoutOrder;\n    }\n\n    function participantDetails(uint orderInPyramid) public view returns(address Address, uint Payout) {\n    if (orderInPyramid <= participants.length) {\n    Address = participants[orderInPyramid].etherAddress;\n    Payout = participants[orderInPyramid].payout / 1 ether;\n    }\n    }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.902,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0057",
    "source": "smartbugs",
    "original_file": "EtherLotto",
    "code_before": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @vulnerable_at_lines: 44\n * @author: -\n */\n\n pragma solidity ^0.5.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() public {\n        bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "code_after": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @vulnerable_at_lines: 44\n * @author: -\n */\n\n pragma solidity ^0.5.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() public {\n    bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n    // Participants must spend some fixed ether before playing lottery.\n    assert(msg.value == TICKET_AMOUNT);\n\n    // Increase pot for each participant.\n    pot += msg.value;\n\n    // Compute some *almost random* value for selecting winner from current transaction.\n    // <yes> <report> TIME_MANIPULATION\n    uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n    // Distribution: 50% of participants will be winners.\n    if (random == 0) {\n\n    // Send fee to bank account.\n    bank.transfer(FEE_AMOUNT);\n\n    // Send jackpot to winner.\n    msg.sender.transfer(pot - FEE_AMOUNT);\n\n    // Restart jackpot.\n    pot = 0;\n    }\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.974,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0058",
    "source": "smartbugs",
    "original_file": "OpenAddressLottery",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @vulnerable_at_lines: 92\n */\n\npragma solidity ^0.5.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @vulnerable_at_lines: 92\n */\n\npragma solidity ^0.5.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The contractOwner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any transferAmount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole userBalance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address contractOwner; //address of the contractOwner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        contractOwner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.ethValue<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.ethValue*7; //win = 7 times the ticket price\n            \n            if(win>address(this).userBalance) //if the userBalance isnt sufficient...\n                win=address(this).userBalance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==contractOwner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the contractOwner - for testing purposes\n        require(msg.sender==contractOwner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.ethValue>=0.1 ether && msg.sender!=contractOwner) //contractOwner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.98,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0059",
    "source": "smartbugs",
    "original_file": "OpenAddressLottery",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @vulnerable_at_lines: 92\n */\n\npragma solidity ^0.5.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @vulnerable_at_lines: 92\n */\n\npragma solidity ^0.5.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:    1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n    uint component1;\n    uint component2;\n    uint component3;\n    uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n    \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n    owner = msg.sender;\n    reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n    if(msg.value<0.1 ether)\n    return; //verify ticket price\n    \n    // make sure he hasn't won already\n    require(winner[msg.sender] == false);\n    \n    if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n    winner[msg.sender] = true; // every address can only win once\n    \n    uint win=msg.value*7; //win = 7 times the ticket price\n    \n    if(win>address(this).balance) //if the balance isnt sufficient...\n    win=address(this).balance; //...send everything we've got\n    msg.sender.transfer(win);\n    }\n    \n    if(block.number-lastReseed>1000) //reseed if needed\n    reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n    // calculate the number of current address - 1 in 8 chance\n    n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n    secretSeed = uint256(keccak256(abi.encodePacked(\n    components.component1,\n    components.component2,\n    components.component3,\n    components.component4\n    ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n    lastReseed = block.number;\n    }\n    \n    function kill() public {\n    require(msg.sender==owner);\n    \n    selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n    require(msg.sender==owner);\n    // <yes> <report> OTHER - uninitialized storage\n    SeedComponents memory s;\n    s.component1 = uint(msg.sender);\n    s.component2 = uint256(blockhash(block.number - 1));\n    s.component3 = block.difficulty*(uint)(block.coinbase);\n    s.component4 = tx.gasprice * 7;\n    \n    reseed(s); //reseed\n    }\n    \n    function () external payable { //if someone sends money without any function call, just assume he wanted to participate\n    if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n    participate();\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.968,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0060",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.5.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call.value(amount)(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.5.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.ethValue;\n  }\n\n  function withdraw(uint transferAmount) public {\n    if (credit[msg.sender]>= transferAmount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call.ethValue(transferAmount)(\"\");\n      credit[msg.sender]-=transferAmount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.958,
    "method": "variation_1",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0061",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.5.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call.value(amount)(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.5.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n    /// @notice Public function\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n    /// @notice Public function\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call.value(amount)(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n    /// @notice Public function\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.935,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0062",
    "source": "smartbugs",
    "original_file": "Government",
    "code_before": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//added pragma version\npragma solidity ^0.5.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() public payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() external payable {\n         lendGovernmentMoney(address(0x0));\n     }\n\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//added pragma version\npragma solidity ^0.5.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() public payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n    /// @notice Public function\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() external payable {\n         lendGovernmentMoney(address(0x0));\n     }\n\n    /// @notice Public function\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n    /// @notice Public function\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    /// @notice Public function\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n    /// @notice Public function\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n    /// @notice Public function\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n    /// @notice Public function\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.979,
    "method": "variation_3",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0063",
    "source": "smartbugs",
    "original_file": "Government",
    "code_before": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//added pragma version\npragma solidity ^0.5.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address payable[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address payable public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     constructor() public payable {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(address(this).balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address payable[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() external payable {\n         lendGovernmentMoney(address(0x0));\n     }\n\n     function totalDebt() public view returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() public view returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() public payable {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address payable nextGeneration) public {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() public view returns (address payable[] memory) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() public view returns (uint[] memory) {\n         return creditorAmounts;\n     }\n }\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 47,49\n */\n\n//added pragma version\npragma solidity ^0.5.0;\n\ncontract Government {\n\n    // Global Variables\n    uint32 public lastCreditorPayedOut;\n    uint public lastTimeOfNewCredit;\n    uint public profitFromCrash;\n    address payable[] public creditorAddresses;\n    uint[] public creditorAmounts;\n    address payable public corruptElite;\n    mapping (address => uint) buddies;\n    uint constant TWELVE_HOURS = 43200;\n    uint8 public round;\n\n    constructor() public payable {\n    // The corrupt elite establishes a new government\n    // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n    profitFromCrash = msg.value;\n    corruptElite = msg.sender;\n    lastTimeOfNewCredit = block.timestamp;\n    }\n\n    function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\n    uint amount = msg.value;\n    // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n    // 12h are on average = 60*60*12/12.5 = 3456\n    if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n    // Return money to sender\n    msg.sender.send(amount);\n    // Sends all contract money to the last creditor\n    creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n    corruptElite.send(address(this).balance);\n    // Reset contract state\n    lastCreditorPayedOut = 0;\n    lastTimeOfNewCredit = block.timestamp;\n    profitFromCrash = 0;\n    // <yes> <report> DENIAL_OF_SERVICE\n    creditorAddresses = new address payable[](0);\n    // <yes> <report> DENIAL_OF_SERVICE\n    creditorAmounts = new uint[](0);\n    round += 1;\n    return false;\n    }\n    else {\n    // the system needs to collect at least 1% of the profit from a crash to stay alive\n    if (amount >= 10 ** 18) {\n    // the System has received fresh money, it will survive at leat 12h more\n    lastTimeOfNewCredit = block.timestamp;\n    // register the new creditor and his amount with 10% interest rate\n    creditorAddresses.push(msg.sender);\n    creditorAmounts.push(amount * 110 / 100);\n    // now the money is distributed\n    // first the corrupt elite grabs 5% - thieves!\n    corruptElite.send(amount * 5/100);\n    // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n    if (profitFromCrash < 10000 * 10**18) {\n    profitFromCrash += amount * 5/100;\n    }\n    // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n    // Make a deal with him.\n    if(buddies[buddy] >= amount) {\n    buddy.send(amount * 5/100);\n    }\n    buddies[msg.sender] += amount * 110 / 100;\n    // 90% of the money will be used to pay out old creditors\n    if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n    creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n    buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n    lastCreditorPayedOut += 1;\n    }\n    return true;\n    }\n    else {\n    msg.sender.send(amount);\n    return false;\n    }\n    }\n    }\n\n    // fallback function\n    function() external payable {\n    lendGovernmentMoney(address(0x0));\n    }\n\n    function totalDebt() public view returns (uint debt) {\n    for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n    debt += creditorAmounts[i];\n    }\n    }\n\n    function totalPayedOut() public view returns (uint payout) {\n    for(uint i=0; i<lastCreditorPayedOut; i++){\n    payout += creditorAmounts[i];\n    }\n    }\n\n    // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    function investInTheSystem() public payable {\n    profitFromCrash += msg.value;\n    }\n\n    // From time to time the corrupt elite inherits it's power to the next generation\n    function inheritToNextGeneration(address payable nextGeneration) public {\n    if (msg.sender == corruptElite) {\n    corruptElite = nextGeneration;\n    }\n    }\n\n    function getCreditorAddresses() public view returns (address payable[] memory) {\n    return creditorAddresses;\n    }\n\n    function getCreditorAmounts() public view returns (uint[] memory) {\n    return creditorAmounts;\n    }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.917,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0064",
    "source": "smartbugs",
    "original_file": "Rubixi",
    "code_before": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * @author: -\n* @vulnerable_at_lines: 23,24\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n pragma solidity ^0.4.15;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         function() {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() onlyowner {\n                 if (collectedFees == 0) throw;\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) throw;\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) throw;\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address _owner) onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) onlyowner {\n                 if (_mult > 300 || _mult < 120) throw;\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) onlyowner {\n                 if (_fee > 10) throw;\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() constant returns(uint multiplier, string info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() constant returns(uint fee, string info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() constant returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() constant returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() constant returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "code_after": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * @author: -\n* @vulnerable_at_lines: 23,24\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n pragma solidity ^0.4.15;\n\n contract Rubixi {\n\n    //Declare variables for storage critical to contract\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address private creator;\n\n    //Sets creator\n    // <yes> <report> ACCESS_CONTROL\n    function DynamicPyramid() {\n    creator = msg.sender; //anyone can call this\n    }\n\n    modifier onlyowner {\n    if (msg.sender == creator) _;\n    }\n\n    struct Participant {\n    address etherAddress;\n    uint payout;\n    }\n\n    Participant[] private participants;\n\n    //Fallback function\n    function() {\n    init();\n    }\n\n    //init function run on fallback\n    function init() private {\n    //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n    if (msg.value < 1 ether) {\n    collectedFees += msg.value;\n    return;\n    }\n\n    uint _fee = feePercent;\n    //50% fee rebate on any ether value of 50 or greater\n    if (msg.value >= 50 ether) _fee /= 2;\n\n    addPayout(_fee);\n    }\n\n    //Function called for valid tx to the contract\n    function addPayout(uint _fee) private {\n    //Adds new address to participant array\n    participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n    //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n    if (participants.length == 10) pyramidMultiplier = 200;\n    else if (participants.length == 25) pyramidMultiplier = 150;\n\n    // collect fees and update contract balance\n    balance += (msg.value * (100 - _fee)) / 100;\n    collectedFees += (msg.value * _fee) / 100;\n\n    //Pays earlier participiants if balance sufficient\n    while (balance > participants[payoutOrder].payout) {\n    uint payoutToSend = participants[payoutOrder].payout;\n    participants[payoutOrder].etherAddress.send(payoutToSend);\n\n    balance -= participants[payoutOrder].payout;\n    payoutOrder += 1;\n    }\n    }\n\n    //Fee functions for creator\n    function collectAllFees() onlyowner {\n    if (collectedFees == 0) throw;\n\n    creator.send(collectedFees);\n    collectedFees = 0;\n    }\n\n    function collectFeesInEther(uint _amt) onlyowner {\n    _amt *= 1 ether;\n    if (_amt > collectedFees) collectAllFees();\n\n    if (collectedFees == 0) throw;\n\n    creator.send(_amt);\n    collectedFees -= _amt;\n    }\n\n    function collectPercentOfFees(uint _pcent) onlyowner {\n    if (collectedFees == 0 || _pcent > 100) throw;\n\n    uint feesToCollect = collectedFees / 100 * _pcent;\n    creator.send(feesToCollect);\n    collectedFees -= feesToCollect;\n    }\n\n    //Functions for changing variables related to the contract\n    function changeOwner(address _owner) onlyowner {\n    creator = _owner;\n    }\n\n    function changeMultiplier(uint _mult) onlyowner {\n    if (_mult > 300 || _mult < 120) throw;\n\n    pyramidMultiplier = _mult;\n    }\n\n    function changeFeePercentage(uint _fee) onlyowner {\n    if (_fee > 10) throw;\n\n    feePercent = _fee;\n    }\n\n    //Functions to provide information to end-user using JSON interface or other interfaces\n    function currentMultiplier() constant returns(uint multiplier, string info) {\n    multiplier = pyramidMultiplier;\n    info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n    }\n\n    function currentFeePercentage() constant returns(uint fee, string info) {\n    fee = feePercent;\n    info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n    }\n\n    function currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\n    pyramidBalance = balance / 1 ether;\n    info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n    }\n\n    function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\n    balancePayout = participants[payoutOrder].payout / 1 ether;\n    }\n\n    function feesSeperateFromBalanceApproximately() constant returns(uint fees) {\n    fees = collectedFees / 1 ether;\n    }\n\n    function totalParticipants() constant returns(uint count) {\n    count = participants.length;\n    }\n\n    function numberOfParticipantsWaitingForPayout() constant returns(uint count) {\n    count = participants.length - payoutOrder;\n    }\n\n    function participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\n    if (orderInPyramid <= participants.length) {\n    Address = participants[orderInPyramid].etherAddress;\n    Payout = participants[orderInPyramid].payout / 1 ether;\n    }\n    }\n }\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.898,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  },
  {
    "pair_id": "bootstrap_0065",
    "source": "smartbugs",
    "original_file": "EtherLotto",
    "code_before": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * @vulnerable_at_lines: 43\n * @author: -\n */\n\n pragma solidity ^0.4.15;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    function EtherLotto() {\n        bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        var random = uint(sha3(block.timestamp)) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "code_after": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * @vulnerable_at_lines: 43\n * @author: -\n */\n\n pragma solidity ^0.4.15;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    function EtherLotto() {\n    bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() payable {\n\n    // Participants must spend some fixed ether before playing lottery.\n    assert(msg.value == TICKET_AMOUNT);\n\n    // Increase pot for each participant.\n    pot += msg.value;\n\n    // Compute some *almost random* value for selecting winner from current transaction.\n    // <yes> <report> TIME_MANIPULATION\n    var random = uint(sha3(block.timestamp)) % 2;\n\n    // Distribution: 50% of participants will be winners.\n    if (random == 0) {\n\n    // Send fee to bank account.\n    bank.transfer(FEE_AMOUNT);\n\n    // Send jackpot to winner.\n    msg.sender.transfer(pot - FEE_AMOUNT);\n\n    // Restart jackpot.\n    pot = 0;\n    }\n    }\n\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.972,
    "method": "variation_4",
    "label_before": "similar",
    "label_after": "similar",
    "needs_manual_review": true,
    "quality_score": 1.0
  }
]