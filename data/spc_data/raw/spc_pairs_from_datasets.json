[
  {
    "pair_id": "syn_0000",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public nonReentrant {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.938749194068343,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true
  },
  {
    "pair_id": "syn_0001",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public nonReentrant {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.938749194068343,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true
  },
  {
    "pair_id": "syn_0002",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public nonReentrant {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call{value: amount}(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.938749194068343,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true
  },
  {
    "pair_id": "syn_0003",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.5.0;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call.value(amount)(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.5.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) public payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public nonReentrant {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      (bool res,) = msg.sender.call.value(amount)(\"\");\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) public view returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.9354180829367778,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true
  },
  {
    "pair_id": "syn_0004",
    "source": "smartbugs",
    "original_file": "SimpleDAO",
    "code_before": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      bool res = msg.sender.call.value(amount)();\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) returns (uint){\n    return credit[to];\n  }\n}\n",
    "code_after": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.4.2;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleDAO is ReentrancyGuard {\n  mapping (address => uint) public credit;\n\n  function donate(address to) payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      bool res = msg.sender.call.value(amount)();\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerability_type": "reentrancy",
    "similarity": 0.9345047923322684,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true
  },
  {
    "pair_id": "syn_0005",
    "source": "solidifi",
    "original_file": "overflow",
    "code_before": "pragma solidity ^0.5.0;\n\n\ncontract Over {\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n\n  function sendeth(address _to, uint _value) public returns (bool) {\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n",
    "code_after": "pragma solidity ^0.5.0;\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n\ncontract Over {\n    using SafeMath for uint256;\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n\n  function sendeth(address _to, uint _value) public returns (bool) {\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n",
    "vulnerability_type": "overflow",
    "similarity": 0.9214659685863874,
    "label_before": "vulnerable",
    "label_after": "patched",
    "method": "synthetic_patch",
    "needs_manual_review": true
  },
  {
    "pair_id": "sim_0000",
    "code_before": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * @vulnerable_at_lines: 43\n * @author: -\n */\n\n pragma solidity ^0.4.15;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    function EtherLotto() {\n        bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        var random = uint(sha3(block.timestamp)) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "code_after": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 45\n * @author: -\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address payable public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    constructor() {\n        bank = payable(msg.sender);\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() public payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        uint random = uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            payable(msg.sender).transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "vulnerability_type": "unknown",
    "similarity": 0.9285309132161089,
    "before_source": "EtherLotto",
    "after_source": "EtherLotto",
    "method": "similarity_matching",
    "needs_manual_review": true
  },
  {
    "pair_id": "sim_0001",
    "code_before": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.5.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "code_after": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "vulnerability_type": "unknown",
    "similarity": 0.9555345316934721,
    "before_source": "ReturnValue",
    "after_source": "ReturnValue",
    "method": "similarity_matching",
    "needs_manual_review": true
  },
  {
    "pair_id": "sim_0002",
    "code_before": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    require(callee.call());\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call();\n  }\n}\n",
    "code_after": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    (bool success,) = callee.call(\"\");\n    require(success);\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call(\"\");\n  }\n}\n",
    "vulnerability_type": "unknown",
    "similarity": 0.7936842105263158,
    "before_source": "ReturnValue",
    "after_source": "ReturnValue",
    "method": "similarity_matching",
    "needs_manual_review": true
  },
  {
    "pair_id": "sim_0003",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.6, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            payable(msg.sender).transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(uint160(msg.sender));\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "unknown",
    "similarity": 0.9666628215480447,
    "before_source": "OpenAddressLottery",
    "after_source": "OpenAddressLottery",
    "method": "similarity_matching",
    "needs_manual_review": true
  },
  {
    "pair_id": "sim_0004",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            payable(msg.sender).transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(uint160(msg.sender));\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "unknown",
    "similarity": 0.967444008312168,
    "before_source": "OpenAddressLottery",
    "after_source": "OpenAddressLottery",
    "method": "similarity_matching",
    "needs_manual_review": true
  },
  {
    "pair_id": "sim_0005",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.5, vulnerability may no longer exist\n * @vulnerable_at_lines: 92\n */\n\npragma solidity ^0.5.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() public {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            payable(msg.sender).transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(uint160(msg.sender));\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "unknown",
    "similarity": 0.9704553354188391,
    "before_source": "OpenAddressLottery",
    "after_source": "OpenAddressLottery",
    "method": "similarity_matching",
    "needs_manual_review": true
  },
  {
    "pair_id": "sim_0006",
    "code_before": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * @vulnerable_at_lines: 91\n */\n\npragma solidity ^0.4.19;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    function OpenAddressLottery() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>this.balance) //if the balance isnt sufficient...\n                win=this.balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;\n    }\n    \n    function reseed(SeedComponents components) internal {\n        secretSeed = uint256(keccak256(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(block.blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}",
    "code_after": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            payable(msg.sender).transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents(uint(uint160(address(block.coinbase))), block.prevrandao, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(uint160(addr)), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(payable(msg.sender));\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(uint160(msg.sender));\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.prevrandao*uint(uint160(address(block.coinbase)));\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerability_type": "unknown",
    "similarity": 0.927710843373494,
    "before_source": "OpenAddressLottery",
    "after_source": "OpenAddressLottery",
    "method": "similarity_matching",
    "needs_manual_review": true
  }
]